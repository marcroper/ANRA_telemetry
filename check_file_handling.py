import requests 
import time
import Telemetry_pb2_grpc, Telemetry_pb2

import grpc
import uuid
import math
import signal
import csv
import queue
from collections import deque
import os
import asyncio


# Modifications made by MR to handle the fact that the file is a live stream of data from the high fidelity Matlab simulation

# queue for telemetry
telem_q = queue.Queue()  # Made a queue - set max size to 1


# MR Added function to simulate the transfer of the matlab generated telemetry
# Generate around once per second
# Do not modify
async def simulate_telemetry_arriving_from_SHEPHERD(telemetry_file):
    print('Reading SHEPHERD data from file ...')
    # with open('ANRA_telemetry120s.txt', 'r', newline='') as data_source:  # Simulated source of SHEPHERD data - this will normally be generated directly from the Matlab code
    with open('ANRA_telemetry_test.txt', 'r',  newline='') as data_source:  # Simulated source of SHEPHERD data - this will normally be generated directly from the Matlab code
        shepherd_reader = csv.reader(data_source)  # safe to us use csv reader? - loads whole file which will not be complete. Not a problem as this is just simulating the generation of data.
        with open(telemetry_file, 'a+', newline='') as data_dest: ## SHEPHERD would be writing directly to this file around once per second and treats it as a csv file. Changed to a+ from w. Is csv file a problem since held in memory?
            shepherd_writer = csv.writer(data_dest)
            for next_line in shepherd_reader:
                shepherd_writer.writerow(next_line)
                print("Task 0: Read/written next line")
                data_dest.flush()
                file_stats = os.stat(telemetry_file)
                print(f'Task 0: File Size in Bytes is {file_stats.st_size}')
                # One of the following
                # time.sleep(1.0)
                await asyncio.sleep(1.0)
                # OLD code - not reading as CSV file - need to check this.
                # If csv option does not work will need to go bck to building up the file field by field.
                # next_line = shepherd_reader.readline()
                # print("Read first line")
                # while next_line:  # while there is still data in the file
                #     shepherd_writer.writerow(next_line)
                #     # asyncio.sleep(1.0)
                #     time.sleep(1.0)
                #     next_line = shepherd_reader.readline()
                #     if not next_line:
                #         print("End of data")
                #         break
                #     print("Read next line")
        print('Task0: No more data')
        # data_source.close()
        # telemetry_file.close()


# Read the file generated by shepherd into a queue for onward transmission.
# Need to accommodate the fact that the shepherd file is generated on the fly
# and we are reading from it as it is generated.
# Also don't know how much data is going to be in the file.
# Can't read it as a csv as originally thought...

# get the next line from the file
# return null if there is nothing more to read
# How does this help? - kicking can down road..
# Need to know if file has changed...
# async def read_next_line_from_file(telemetry_file):



# Reads the next line of telemetry data and adds it to the queue.
async def add_next_line_to_queue(telemetry_source):
    print('Task 1: Reading from file ...')
    # set pointer to start
    # telemetry_file.seek(0)
    file_stats = os.stat('TEST_ANRA_telemetry.txt')
    print(f'File Size in Bytes is {file_stats.st_size}')
    line = telemetry_source.readline() # Push this out into a separate function and wait on it?
    count =0
    while not line and count < 10: # Give it 5 seconds
        # PROBLEM - once it gets in here it doesn't seem to get out...
        await asyncio.sleep(0.5) # wait for data to arrive
        file_stats = os.stat('TEST_ANRA_telemetry.txt')
        print(f'IN LOOP: File Size in Bytes is {file_stats.st_size}')
        line = telemetry_source.readline() # and try again
        count += 1
        print(f"Count is {count}")
        print(f"and line is {line}")
    if line:
        telem_q.put(line) # if the line is there then add it to the queue. Could block on this
        print(f"Task 1: Line added to Q: {line}")
        return 1
    else:
        print(f"Task 1: No more data to read from file")
        return 0

async def populate_queue(telemetry_file):
    print(f"Building up the the queue")
    # Open up telemetry file for reading
    telemetry_source = open('TEST_ANRA_telemetry.txt', 'r', newline='')
    while True:
        print(f"Calling add to Q")
        result = await add_next_line_to_queue(telemetry_source)
        if not result:
            print(f"No more data to add")
            break

# Test asynch queue handling
async def read_line_from_queue():
    print(f"Reading line from Q")
    qcount = 0
    while (telem_q.qsize() <= 0 and qcount < 10):
        print(f'No pending data from telemetry file. Pending records: {telem_q.qsize()} and qcount is {qcount}')  # MR How do we get out of this if all the data has been transferred?
        await asyncio.sleep(0.5)
        qcount += 1
    if (telem_q.qsize() > 0):
        qcontents = telem_q.get()
        print(f"Line removed from Q: {qcontents}")
        return qcontents
    else:
        print(f"No more data to read from queue")
        return 0


# don't think we need the following... Yes we do
async def process_queue():
    print(f"TestTask: Start working through the queue")
    # How do we terminate this???
    # Run through 20 for now but need to make more general
    while True:
        print(f"Calling read from Q")
        result = await read_line_from_queue()
        if not result:
            print(f"No more data to retrieve from Q")
            break


async def main():
    # g = GrpcClient()
    telemetry_file = 'TEST_ANRA_telemetry.txt'
    # telemetry_file = open('TEST_ANRA_telemetry.txt', 'a+', newline='') # or changed from w+
    task0 = asyncio.create_task(simulate_telemetry_arriving_from_SHEPHERD(telemetry_file))

    # time.sleep(2.0) # give it a chance to get going...

    # task1 = asyncio.create_task(add_next_line_to_queue())
    taskPopulateQ = asyncio.create_task(populate_queue(telemetry_file))
    taskProcessQ = asyncio.create_task(process_queue())

    # tasktest = asyncio.create_task(process_queue())
    # read_from_q_task = asyncio.create_task(read_from_queue())  # MR added
    # task2 = asyncio.create_task(g.post_telemetry())
    await asyncio.gather(task0, taskPopulateQ, taskProcessQ)
    print(f"Queue size is {telem_q.qsize()}")
    #Fail to run asyc now (run sychronously instead)
    # await task0
    # await task1
    # await tasktest
    # await task2
    
# Hmm... runs one after the other... not ideal.
# Getting better but not sure - need to check await
# Does read_from_queue need to be awaited - create task in calling function???
# Now just reading one record and not getting any further - stuck in task 1....
# See what size of file is - 0 as guessed. OK, how to get around this - wait until file is touched - await something arriving???
# And read up on how asynch and await actually work!
    
asyncio.run(main())